/*
Low-level proof generation.
These functions are directly calling proof generation functions
    from snarkJs library
*/

// Generating proof for AuctionInit.circom
async function AuctionInitProof(
    st_beacon,
    tokenId,
    wt_contractAddress,
    keyIn,
    merkleDepth,
    merkleProof,
    merkleRoot,
    st_treeNumber,
    vaultId,
    assetGroup_merkleRoot,
    assetGroup_merkleProof,
    wt_idParams
) {
    let wt_pathElements = merkleProof.elements;
    
    const wt_pathIndices = merkleProof.indices;

    // console.log("wt_pathIndices: ", JSON.stringify(wt_pathIndices, null, 4));
    const st_nullifier = utils.getNullifier(keyIn.privateKey, wt_pathIndices);

    // generating uniqueId based on vaultId
    // it can be generated by web3 call to CoinVault[vaultId].generateUniqueId()
    let uniqueId;
    if(vaultId == 0){
        uniqueId = utils.erc20UniqueId(wt_contractAddress, wt_idParams[0]);
    }
    else if(vaultId == 1){
        uniqueId = utils.erc721UniqueId(wt_contractAddress, wt_idParams[0]);
    }
    else if(vaultId == 2){
        uniqueId = utils.erc1155UniqueId(wt_contractAddress, wt_idParams[1], wt_idParams[0]);
    }

    const wt_commitment = utils.getCommitment(uniqueId, keyIn.publicKey);
    const st_auctionId = utils.getAuctionId(wt_commitment);

    const { ws, pk } = { ws: wasm.auctionInitErc721, pk: pKeys.auctionInitErc721 };

    let wt_assetGroup_pathElements;
    if(assetGroup_merkleRoot != 0){
        wt_assetGroup_pathElements = assetGroup_merkleProof.elements;
    }
    else{
        wt_assetGroup_pathElements = []
        for(var i = 0; i < merkleDepth; i++){
                wt_assetGroup_pathElements.push(0n);
        }
    }
    
    let wt_assetGroup_pathIndices = 0;
    if(assetGroup_merkleRoot != 0){
        wt_assetGroup_pathIndices = assetGroup_merkleProof.indices;
    }


    const circuitInputs = {
        st_beacon,
        st_vaultId: vaultId,
        st_auctionId,
        st_nullifier,
        st_treeNumber,
        st_merkleRoot: merkleRoot,
        wt_privateKey: keyIn.privateKey,
        wt_pathElements,
        wt_pathIndices,
        wt_commitment,
        st_assetGroup_merkleRoot:assetGroup_merkleRoot,
        wt_assetGroup_pathElements,
        wt_assetGroup_pathIndices,
        wt_idParams,
        wt_contractAddress
    };
    let curve = await snarkjs.curves.getCurveFromName("bn128");

    const fullProof = await snarkjs.groth16.fullProve(circuitInputs, ws, pk);
    const solidityProof = formatProof(fullProof.proof);

    curve.terminate();

    let statement = [
                                        st_beacon,
                                        vaultId,
                                        st_auctionId,
                                        st_treeNumber,
                                        merkleRoot,
                                        st_nullifier,
                                        assetGroup_merkleRoot
                                    ];

    return {
        proof: solidityProof,
        statement,
        numberOfInputs: 1,
        numberOfOutputs: 1
    };
}


// Generating proof for AuctionBidErc20.circom
async function AuctionBidProof(
    st_auctionId,
    wt_bidAmount,
    wt_bidRandom,
    assetAddress,
    wt_valuesIn,
    keysIn,
    wt_valuesOut,
    keysOut,
    merkleDepth,
    merkleProofs,
    st_merkleRoots,
    st_treeNumbers,
    st_vaultId,
    wt_idParamsIn,
    wt_idParamsOut,
    st_assetGroup_merkleRoot,
    assetGroup_merkleProof,
) {


    const st_blindedBid = utils.pedersen(wt_bidAmount, wt_bidRandom);
    const st_commitmentsOut = [];
    const st_nullifiers = [];
    const wt_pathIndices = [];
    let wt_pathElements = [];

    for (let i = 0; i < wt_valuesIn.length; i++) {    
        let uniqueId;
            if(st_vaultId == 0){
                uniqueId = utils.erc20UniqueId(assetAddress, wt_idParamsIn[i][0]);
            }
            else if(st_vaultId == 1){
                uniqueId = utils.erc721UniqueId(assetAddress, wt_idParamsIn[i][0]);
            }
            else if(st_vaultId == 2){
                uniqueId = utils.erc1155UniqueId(assetAddress, wt_idParamsIn[i][1], wt_idParamsIn[i][0]);
            }
        const cmt = utils.getCommitment(uniqueId, keysIn[i].publicKey);

        if (wt_valuesIn[i] === 0n) {
            wt_pathIndices[i] = 0;
            wt_pathElements.push(new Array(merkleDepth).fill(0n));
        } else {
            wt_pathIndices[i] = merkleProofs[i].indices;
            wt_pathElements.push(merkleProofs[i].elements);
        }
        st_nullifiers.push(utils.getNullifier(keysIn[i].privateKey, wt_pathIndices[i]));
    }
    for (let i = 0; i < keysOut.length; i++) {
        let uniqueIdOut;
            if(st_vaultId == 0){
                uniqueIdOut = utils.erc20UniqueId(assetAddress, wt_idParamsOut[i][0]);
            }
            else if(st_vaultId == 1){
                uniqueIdOut = utils.erc721UniqueId(assetAddress, wt_idParamsOut[i][0]);
            }
            else if(st_vaultId == 2){
                uniqueIdOut = utils.erc1155UniqueId(assetAddress, wt_idParamsOut[i][1], wt_idParamsOut[i][0]);
            }
                
        st_commitmentsOut.push(utils.getCommitment(uniqueIdOut, keysOut[i].publicKey));
    }
    wt_pathElements = wt_pathElements.flat(1);

    const { ws, pk } = { ws: wasm.auctionBidErc20, pk: pKeys.auctionBidErc20 };

        // // Statement
        // signal input st_auctionId; 
        // signal input st_blindedBid;
        // signal input st_vaultId; 
        // signal input st_treeNumbers[nInputs];
        // signal input st_merkleRoots[nInputs];
        // signal input st_nullifiers[nInputs];
        // signal input st_commitmentsOut[nInputs];
        // signal input st_assetGroup_merkleRoot;

        // // Witness    
        // signal input wt_bidAmount;
        // signal input wt_bidRandom;

        // signal input wt_privateKeys[nInputs];
        // signal input wt_valuesIn[nInputs];
        // signal input wt_pathElements[nInputs][MerkleTreeDepth];
        // signal input wt_pathIndices[nInputs];
        // signal input wt_assetContractAddress;

        // signal input wt_recipientPK[mOutputs]; 
        // signal input wt_valuesOut[mOutputs];

        // // has been added to support assetGroup membership proof
        // signal input wt_assetGroup_pathElements[assetGroupMerkleTreeDepth];
        // signal input wt_assetGroup_pathIndices;

        // // for generic standard support
        // signal input wt_idParamsIn[nInputs][5];
        // signal input wt_idParamsOut[mOutputs][5];
    let wt_assetGroup_pathElements;
    if(st_assetGroup_merkleRoot != 0){
        wt_assetGroup_pathElements = assetGroup_merkleProof.elements;
    }
    else{
        wt_assetGroup_pathElements = []
        for(var i = 0; i < merkleDepth; i++){
                wt_assetGroup_pathElements.push(0n);
        }
    }
    
    let wt_assetGroup_pathIndices = 0;
    if(st_assetGroup_merkleRoot != 0){
        wt_assetGroup_pathIndices = assetGroup_merkleProof.indices;
    }

    const circuitInputs = {
        st_auctionId,
        st_blindedBid,
        st_vaultId,
        st_merkleRoots,
        st_nullifiers,
        st_treeNumbers,
        st_commitmentsOut,
        wt_bidAmount,
        wt_bidRandom,
        wt_privateKeys: keysIn.map((k) => k.privateKey),
        wt_valuesIn,
        wt_pathElements,
        wt_pathIndices,
        wt_assetContractAddress: BigInt(assetAddress),
        wt_recipientPK: keysOut.map((k) => k.publicKey), 
        wt_valuesOut,
        st_assetGroup_merkleRoot,
        wt_assetGroup_pathIndices,
        wt_assetGroup_pathElements,
        wt_idParamsIn: wt_idParamsIn.flat(1),
        wt_idParamsOut: wt_idParamsOut.flat(1)
    };
    let curve = await snarkjs.curves.getCurveFromName("bn128");

    const fullProof = await snarkjs.groth16.fullProve(circuitInputs, ws, pk);
    const solidityProof = formatProof(fullProof.proof);

    let statement = [
                        st_auctionId, 
                        st_blindedBid,
                        st_vaultId
                    ].concat(st_treeNumbers)
                    .concat(st_merkleRoots)
                    .concat(st_nullifiers)
                    .concat(st_commitmentsOut)
                    .concat([st_assetGroup_merkleRoot]);
    curve.terminate();
    return {
        proof: solidityProof,
        statement,
        numberOfInputs:2,
        numberOfOutputs:2
    };
}



async function AuctionPrivateOpeningProof(
    st_auctionId,
    st_blindedBid,
    wt_bidAmount,
    wt_bidRandom
) {

    const { ws, pk } = { ws: wasm.auctionPrivateOpening, pk: pKeys.auctionPrivateOpening };

    const circuitInputs = {
        st_auctionId,
        st_blindedBid,
        wt_bidAmount,
        wt_bidRandom
    };
    let curve = await snarkjs.curves.getCurveFromName("bn128");

    const fullProof = await snarkjs.groth16.fullProve(circuitInputs, ws, pk);
    const solidityProof = formatProof(fullProof.proof);

    curve.terminate();

    const statement = [st_auctionId, st_blindedBid];
    return {
        proof: solidityProof,
        statement,
        numberOfInputs: 1,
        numberOfOutputs: 1
    };
}

// Generates proof for AuctionNotWinningBid.circom
// proves that a bid is less than the winning bid.
async function AuctionNotWinningBidProof(
    st_auctionId,
    st_bidBlockNumber,
    st_winningBidBlockNumber,
    wt_bidAmount,
    wt_bidRandom,
    wt_winningBidAmount,
    wt_winningBidRandom
) {

        const blindedBid = utils.pedersen(wt_bidAmount, wt_bidRandom);
        const blindedWinningBid = utils.pedersen(wt_winningBidAmount, wt_winningBidRandom);

        // adding utils.SNARK_SCALAR_FIELD to avoid negative values
        const st_blindedBidDifference = (blindedWinningBid - blindedBid + utils.SNARK_SCALAR_FIELD) % utils.SNARK_SCALAR_FIELD;

        const { ws, pk } = { 
                ws: wasm.auctionNotWinningBid, 
                pk: pKeys.auctionNotWinningBid 
        };

        const circuitInputs = {
            st_auctionId,
            st_blindedBidDifference,
            st_bidBlockNumber,
            st_winningBidBlockNumber,
            wt_bidAmount,
            wt_bidRandom,
            wt_winningBidAmount,
            wt_winningBidRandom
        };
        let curve = await snarkjs.curves.getCurveFromName("bn128");

        const fullProof = await snarkjs.groth16.fullProve(circuitInputs, ws, pk);
        const solidityProof = formatProof(fullProof.proof);

        curve.terminate();

        const statement = [     
                                                st_auctionId, 
                                                st_blindedBidDifference, 
                                                st_bidBlockNumber, 
                                                st_winningBidBlockNumber
                                        ];
        return {
                proof: solidityProof,
                statement,
                numberOfInputs: 1,
                numberOfOutputs: 1
        };
}

//-----------------------------------------------------
//                            BROKER FUNCTIONS
//-----------------------------------------------------
async function BrokerRegistrationProof(
        st_beacon,
        st_vaultId,
        st_groupId,
        delegator_keys,
        merkleDepth,
        st_delegator_treeNumbers,
        delegator_merkleProofs,
        wt_delegator_idParams,
        wt_broker_publicKey,
        wt_contractAddress,
        st_assetGroup_treeNumber,
        assetGroup_merkleProof,
        st_broker_minCommissionRate,
        st_broker_maxCommissionRate
) {

        // const pathElements = delegator_merkleProof.elements;
        // const pathIndices = delegator_merkleProof.indices;
        // const st_delegator_nullifier = utils.getNullifier(delegator_key.privateKey, pathIndices);
        const st_broker_blindedPublicKey = utils.blindedPublicKey(wt_broker_publicKey);
        let st_delegator_merkleRoots = [];
        const st_assetGroup_merkleRoot = assetGroup_merkleProof.root;

        const st_delegator_nullifiers = [];
        const pathIndices = [];
        let pathElements = [];

        for (let i = 0; i < delegator_keys.length; i++) {
                st_delegator_merkleRoots.push(delegator_merkleProofs[i].root);
                let uniqueIdIn;
                if(st_vaultId == 0){
                        uniqueIdIn = utils.erc20UniqueId(wt_contractAddress, wt_delegator_idParams[i][0]);
                }
                else if(st_vaultId == 1){
                        uniqueIdIn = utils.erc721UniqueId(wt_contractAddress, wt_delegator_idParams[i][0]);
                }
                else if(st_vaultId == 2){
                        uniqueIdIn = utils.erc1155UniqueId(wt_contractAddress, wt_delegator_idParams[i][1], wt_delegator_idParams[i][0]);
                }

                const cmt = utils.getCommitment(uniqueIdIn, delegator_keys[i].publicKey);

                if ( wt_delegator_idParams[i][0] == 0n) {
                        pathIndices[i] = 0;
                        pathElements.push(new Array(merkleDepth).fill(0n));
                } else {
                        pathIndices[i] = delegator_merkleProofs[i].indices;
                        pathElements.push(delegator_merkleProofs[i].elements);
                }
                st_delegator_nullifiers[i] = utils.getNullifier(delegator_keys[i].privateKey, pathIndices[i]);
        }

        const { ws, pk } = { 
                ws: wasm.brokerRegistration, 
                pk: pKeys.brokerRegistration 
        };

        const circuitInputs = {
                st_beacon,
                st_vaultId,
                st_groupId,
                st_delegator_treeNumbers,
                st_delegator_merkleRoots ,
                st_delegator_nullifiers,
                st_broker_blindedPublicKey,
                st_assetGroup_treeNumber,
                st_assetGroup_merkleRoot,
                wt_delegator_privateKeys: delegator_keys.map((k) => k.privateKey),
                wt_delegator_pathElements: pathElements,
                wt_delegator_pathIndices: pathIndices,
                wt_delegator_idParams,
                wt_contractAddress,
                wt_broker_publicKey,
                wt_assetGroup_pathIndices: assetGroup_merkleProof.indices,
                wt_assetGroup_pathElements: assetGroup_merkleProof.elements,
                st_broker_minCommissionRate,
                st_broker_maxCommissionRate,

        };

        let curve = await snarkjs.curves.getCurveFromName("bn128");

        const fullProof = await snarkjs.groth16.fullProve(circuitInputs, ws, pk);
        const solidityProof = formatProof(fullProof.proof);

        curve.terminate();

        let statement = [
                st_beacon, 
                st_vaultId,
                st_groupId
        ].concat(st_delegator_treeNumbers).
                concat(st_delegator_merkleRoots).
                concat(st_delegator_nullifiers).
                concat(
                        [
                                st_broker_blindedPublicKey,
                                st_broker_minCommissionRate,
                                st_broker_maxCommissionRate,
                                st_assetGroup_treeNumber,
                                st_assetGroup_merkleRoot
                        ]
                );

        console.log("statement : ", JSON.stringify(statement, null, 4));
    return {
        proof: solidityProof,
        statement,
        numberOfInputs:st_delegator_merkleRoots.length,
        numberOfOutputs:0
    };
}

async function LegitBrokerProof(
    st_beacon,
    wt_privateKey
) {

    const { ws, pk } = { ws: wasm.legitBroker, pk: pKeys.legitBroker };
    const publicKey = utils.getPublicKey(wt_privateKey);
    const st_blindedPublicKey = utils.blindedPublicKey(publicKey)
    const circuitInputs = {
        st_beacon,
        st_blindedPublicKey,
        wt_privateKey
    };
    let curve = await snarkjs.curves.getCurveFromName("bn128");

    const fullProof = await snarkjs.groth16.fullProve(circuitInputs, ws, pk);
    const solidityProof = formatProof(fullProof.proof);

    curve.terminate();

    const statement = [st_beacon, st_blindedPublicKey];
    return {
        proof: solidityProof,
        statement,
        numberOfInputs: 0,
        numberOfOutputs: 0
    };
}


async function Erc20WithBrokerV1Proof(
    st_message,
    wt_valuesIn,
    keysIn,
    wt_valuesOut,
    keysOut,
    merkleDepth,
    merkleProofs,
    st_treeNumbers,
    wt_erc20ContractAddress,
    st_broker_blindedPublicKey
) {

    var ws;
    var pk;
    if(valuesIn.length == 2){
     ws = wasm.erc20JoinSplitWithBrokerV1;
     pk = pKeys.erc20JoinSplitWithBrokerV1;
    }
// activate for 10 input joinSplitWithBrokerV1
    // else{
    //    ws = wasm.js102;
    //    pk = pKeys.js102;

    //    for(var i = valuesIn.length;i < 10; i++){
    //     valuesIn.push(0n);
    //     keysIn.push({publicKey: 0n, privateKey:0n});
    //     merkleRoots.push(0n);
    //     treeNumbers.push(0n);
    //    }

    // }

    const st_commitmentsOut = [];
    const st_nullifiers = [];
    const wt_pathIndices = [];
    let wt_pathElements = [];
    for (let i = 0; i < valuesIn.length; i++) {
        const idIn = utils.erc20UniqueId(wt_erc20ContractAddress, wt_valuesIn[i]);
        const cmt = utils.getCommitment(idIn, keysIn[i].publicKey);

        if (wt_valuesIn[i] === 0n) {
            wt_pathIndices[i] = 0;
            wt_pathElements.push(new Array(merkleDepth).fill(0n));
        } else {
            // const merkleProof = merkleTrees[i].generateProof(cmt);
            wt_pathIndices[i] = merkleProofs[i].indices;
            wt_pathElements.push(merkleProofs[i].elements);
        }
        st_nullifiers[i] = utils.getNullifier(keysIn[i].privateKey, wt_pathIndices[i]);
    }
    for (let i = 0; i < keysOut.length; i++) {
        const idOut = utils.erc20UniqueId(wt_erc20ContractAddress, wt_valuesOut[i]);

        st_commitmentsOut[i] = utils.getCommitment(idOut, keysOut[i].publicKey);
    }
    wt_pathElements = wt_pathElements.flat(1);

    const st_merkleRoots = merkleProofs.map((k) => k.root);
    const circuitInputs = {
        st_message,
        st_treeNumbers,
        st_merkleRoots,
        st_nullifiers,
        st_commitmentsOut,
        st_broker_blindedPublicKey,
        wt_valuesIn,
        wt_privateKeys: keysIn.map((k) => k.privateKey),
        wt_pathElements,
        wt_pathIndices,
        wt_publicKeysOut: keysOut.map((k) => k.publicKey),
        wt_erc20ContractAddress,
        wt_valuesOut,
    };
    let curve = await snarkjs.curves.getCurveFromName("bn128");

    const fullProof = await snarkjs.groth16.fullProve(circuitInputs, ws, pk);
    const solidityProof = formatProof(fullProof.proof);

    curve.terminate();

    let statement = [st_message]
                                        .concat(treeNumbers)
                                        .concat(merkleRoots)
                                        .concat(st_nullifiers)
                                        .concat(st_commitmentsOut)
                                        .concat([st_broker_blindedPublicKey]);
    return {
        proof: solidityProof,
        numberOfInputs: valuesIn.length,
        numberOfOutputs: valuesOut.length,
        statement
    };
}

async function Erc1155FungibleWithBrokerV1Proof(
    message,
    valuesIn,
    keysIn,
    valuesOut,
    keysOut,
    merkleDepth,
    treeNumbers,
    merkleProofs,
    erc1155ContractAddress,
    erc1155TokenId,
    st_assetGroup_treeNumber,
    assetGroup_merkleProof,
    brokerPublicKey,
    st_broker_commissionRate
) {
        var tokenIds = []
        for(var i = 0; i< 10;i++){
                tokenIds.push(erc1155TokenId);
        }
    let [commitmentsOut, nullifiers, pathIndices, pathElements] =
        prepareErc1155ProofParameters(
            message,
            valuesIn,
            keysIn,
            valuesOut,
            keysOut,
            merkleDepth,
            merkleProofs,
            erc1155ContractAddress,
            tokenIds
        );
            const st_broker_blindedPublicKey = utils.blindedPublicKey(brokerPublicKey)


        let wt_assetGroup_pathElements = [];
        let wt_assetGroup_pathIndices = assetGroup_merkleProof.indices;
        wt_assetGroup_pathElements.push(assetGroup_merkleProof.elements);

        var { ws, pk } = { 
                ws: wasm.erc1155JoinSplitWithBrokerV1, 
                pk: pKeys.erc1155JoinSplitWithBrokerV1 
        };

        const merkleRoots = merkleProofs.map((k) => k.root);

        const circuitInputs = {
                st_message: message,
                st_treeNumbers: treeNumbers,
                st_merkleRoots: merkleRoots,
                st_nullifiers: nullifiers,
                st_commitmentsOut: commitmentsOut,
                st_broker_blindedPublicKey,
                st_broker_commissionRate,
                st_assetGroup_treeNumber,
                st_assetGroup_merkleRoot: assetGroup_merkleProof.root,
                wt_valuesIn: valuesIn,
                wt_privateKeys: keysIn.map((k) => k.privateKey),
                wt_pathElements: pathElements,
                wt_pathIndices: pathIndices,
                wt_recipientPK: keysOut.map((k) => k.publicKey),
                wt_valuesOut: valuesOut,
                wt_erc1155ContractAddress: erc1155ContractAddress,
                wt_erc1155TokenId: erc1155TokenId,
                wt_assetGroup_pathElements,
                wt_assetGroup_pathIndices,
        };
        let curve = await snarkjs.curves.getCurveFromName("bn128");

        const fullProof = await snarkjs.groth16.fullProve(circuitInputs, ws, pk);
        const solidityProof = formatProof(fullProof.proof);

        curve.terminate();
        // signal input st_message; //public
        // signal input st_treeNumbers[nInputs];
        // signal input st_merkleRoots[nInputs];
        // signal input st_nullifiers[nInputs];
        // signal input st_commitmentsOut[mOutputs];
        // signal input st_broker_blindedPublicKey;
        // signal input st_assetGroup_treeNumber;
        // signal input st_assetGroup_merkleRoot;
        let statement = [message].
                                        concat(treeNumbers).
                                        concat(merkleRoots).
                                        concat(nullifiers).
                                        concat(commitmentsOut).
                                        concat([
                                                st_broker_blindedPublicKey,
                                                st_broker_commissionRate,
                                                st_assetGroup_treeNumber, 
                                                assetGroup_merkleProof.root
                                        ]);

        console.log(JSON.stringify(statement, null, 4));
    return {
        proof: solidityProof,
        statement,
        numberOfInputs:valuesIn.length,
        numberOfOutputs: valuesOut.length
    };
}

module.exports = {
        prove,
        AuctionInitProof,
        AuctionBidProof,
        AuctionPrivateOpeningProof,
        AuctionNotWinningBidProof,
        BrokerRegistrationProof,
        LegitBrokerProof,
        Erc20WithBrokerV1Proof,
        Erc1155FungibleWithBrokerV1Proof,
};
